#  Level Up Your SwiftUI



Ten film nosi tytuł "Podnieś swój SwiftUI". Celem tutaj jest pomóc Ci podejść krok po kroku do poprawy swojego kodu, począwszy od starszego kodu SwiftUI, aż do nowszego, lepszego kodu SwiftUI. Być może zauważyłeś w tym roku, że Apple delikatnie zmieniło logo SwiftUI. Stare po lewej, nowe po prawej. Myślę, że to się stało, ponieważ wprowadzili również Swift Data. I umieściliśmy te dwa loga obok klasycznego logo Swift. Nazwałem te trzy razem logami ptaka. Jeśli się zastanowisz, w zeszłym roku dodali Swift Charts. Swift Charts nie dostał logo ptaka. Myślę, że to jest celowe. Myślę, że Apple daje nam tutaj sygnał. To, co widzimy, to nowe Coco. Ponieważ w starej metodzie tworzenia aplikacji w Objective-C używałbyś Foundation do wszystkich swoich standardowych bibliotek. Używałbyś AppKit do wszystkich swoich elementów interfejsu użytkownika. A do przechowywania i zarządzania danymi używałbyś Core Data. A teraz mamy Swift, standardową bibliotekę. Mamy SwiftUI. I mamy SwiftData. To jest nowe Coco. W każdym razie, ta prezentacja skupia się tylko na części SwiftUI. Tutaj nie ma SwiftData, ani obserwacji i podobnych, tylko czysty kod SwiftUI. Zobaczysz wiele rzeczy, które są nowe w iOS 17. Niektóre rzeczy będą działać już w iOS 16. Kilka rzeczy będzie działać wstecz do iOS 15, a nawet wstecz do iOS 14, i wierz lub nie, nawet wstecz do iOS 13. W każdym razie, zaczynajmy. W tym roku miałem wakacje w Japonii, gdzie widziałem wiele bardzo starych rzeczy, oraz wiele bardzo nowych rzeczy, zanurzyłem się w różnorodnej kulturze i oczywiście jadłem mnóstwo jedzenia. Gdybym był normalny, zakończyłbym tutaj i cieszył się Japonią, świetnie się bawiąc. Ale jesteśmy programistami. Więc to, co zamierzamy zrobić, to stworzyć aplikację opisującą nasze doświadczenia.





W naszym przypadku stworzyłem tutaj aplikację na rok 2023 związana z Japonią. Jak widzisz, jest tu wiele potraw, przez które mogę przesuwać palcem, aby zobaczyć rzeczy, które mi się podobały w Japonii. Mogę przesuwać się w pionie, aby zobaczyć napoje, a potem przejść dalej i zobaczyć aktywności - rzeczy, które robiłem w Japonii. Aplikacja ma także funkcję wyszukiwania. Mogę np. wpisać coś prostego, jak "Shin", i znajdzie Yoshinoya. Jest także przycisk "Lubię" do oznaczenia, że zrobiłem daną rzecz. Mogę śledzić, jak często jadłem jedzenie z Yoshinoya lub jeździłem Shinkansenem. Tego robiłem dużo, więc wiele razy oznaczyłem, że to zrobiłem, bardzo to lubię. I to cały projekt. Jest bardzo, bardzo prosty celowo. Nie jest zaprojektowany, aby być skomplikowany. To taka mała piaskownica dla naszych nowych funkcji. Teraz, patrząc na to, to jest bardzo prosty interfejs. Patrzymy na wiele widoków rozłożonych na ekranie poziomo, i to samo w pionie dla różnych kategorii. I gdy użytkownicy przesuwają się między rzeczami, po prostu przesuwamy je jedno miejsce na raz, za każdym razem. Ale co się dzieje, gdy użytkownik wraca częściowo? Nie przewinął całej drogi. 



![image-20230918214045445](image-20230918214045445.png)

To jest bardzo dziwne miejsce. Nie można naprawdę zobaczyć niczego użytecznego na ekranie. I to widać w naszej aplikacji. Tutaj, jeśli po prostu przesuwam się między różnymi rzeczami, mogę powiedzieć: "To fajne, ale zostawmy to tutaj". Albo co gorsza, zatrzymać się poziomo, a potem także częściowo w pionie. Aplikacja jest teraz w zupełnie bezużytecznym stanie. Nie można widzieć niczego w pełni na ekranie. To jest teraz rozwiązywalne w iOS 17.





Istnieje teraz nowy modyfikator dla widoków przewijalnych nazywany "scroll target behavior". Możemy powiedzieć "paging", co oznacza, że w miarę przesuwania przez użytkownika, przesuwamy o całą stronę zawartości na raz. Lub możemy powiedzieć  `.scrollTargetBehavior(.viewAligned)`, co oznacza przewijanie między różnymi widokami, które podaję, przeskakując do każdego z nich osobno, a nie całe strony naraz. Jak powiedzieć, do którego elementu przeskoczyć? To proste. Możemy użyć  `.scrollTargetLayout()` dla całego kontenera, takiego jak H stack lub V stack. Będzie przeskakiwać do poszczególnych elementów wewnątrz tego widoku. To naprawdę proste i bardzo przydatne. Oto nasz kod. 

```swift
struct ListingView: View {
    ...
    var body: some View {
        NavigationStack {...

                        ScrollView(...)
                            .padding(.horizontal, 20)
                            .scrollTargetLayout()
                        }
                        .listRowInsets(EdgeInsets())
                        .scrollTargetBehavior(.viewAligned)
                    } header: {
                        Text(dataModel.title(for: category))
                            .font(.title3.bold())
                            .textCase(.uppercase)
                    }
  ...
```



Zobaczysz, że to jest nasz główny widok listy. Mamy tutaj dużą listę treści, idących w dół ekranu. Wewnątrz niego pętlujemy przez wszystkie nasze kategorie, czyli jedzenie, napoje, aktywności. Wewnątrz nich odczytujemy wszystkie elementy dla danej kategorii. Każdy z nich pokazujemy w osobnym widoku przewijalnym, rozciągniętym poziomo. W tym widoku przewijalnym mamy H stack zawierający treść dla wszystkich potraw lub napojów. Wewnątrz tego pętlujemy przez każdą rzecz za pomocą widoku "item view", który pokazuje każdy element na ekranie. Więc mieliśmy tam salon gier, maszyny gacha i podobne. Jest także trochę marginesu dla tego wewnętrznego H-Stack, aby elementy nie wychodziły na brzegi ekranu. Potrzebuje trochę przestrzeni. Teraz zaktualizujemy to na iOS 17. Zacznijmy od dodania nowego modyfikatora do widoku przewijalnego, mówiąc, że "scroll target behavior" to "view aligned". Przeskakuj do dzieci wewnątrz widoku przewijalnego, które mu podam. W tej chwili to jeszcze nic, ale powiemy temu HStackowi wewnątrz widoku przewijalnego, że chcemy, aby przeskakiwał do każdego dziecka wewnątrz niego. Każdy "item view" powinien być przeskakiwany, gdy przewijamy widok przewijalny. To tylko dwie linie kodu, dwa nowe modyfikatory dla naszego kodu SwiftUI, ale efekt jest naprawdę świetny.



Wracając do naszego kodu, teraz mogę przesuwać się między różnymi widokami i zauważysz, że każdy przeskakuje do indywidualnych elementów w kategorii jedzenia po jednym. Jeśli spróbuję wrócić częściowo i puścić, nagle przeskoczy do najbliższego widoku. W tym przypadku "Eki-ben".W każdym razie to duże ulepszenie, ale daleko od ideału. Spójrz na to na przykład. Widzimy białą przestrzeń po lewej stronie. To nie jest dobra rzecz. Chcieliśmy odstępu wcześniej, aby nie wypełniało ekranu całkowicie i nie wylewało się wszędzie. Teraz wygląda na zepsute. Jest to spowodowane wcześniejszym modyfikatorem "padding". Dodawanie trochę odstępu było dobre, ale teraz dodaje twardą białą linię z obu stron. To nie jest idealne. Modyfikator "padding", jak wiesz, jeśli masz długi widok przewijalny z zawartością i zastosujesz "padding" do tej zawartości, to przytnie ją od krawędzi początkowej i końcowej tej zawartości. Tutaj mówię  `.padding(.horizontal, 20)` to przytnie zawartość od krawędzi początkowej i końcowej o 20 wewnątrz widoku przewijalnego. Jeśli dodamy 40, to przytnie jeszcze bardziej. To działa dobrze dla prostego odstępu. Ale nie chcemy tego tutaj. Zamiast tego użyjemy nowego modyfikatora iOS 17, który nazywa się  `.contentMargins(20, for: .scrollContent)`,. Zmienia on obszar bezpieczny wewnątrz widoku przewijalnego. Rzeczy przewijane wewnątrz niego przewijają się w mniejszej przestrzeni. Oto 20 lub 40, tak jak to. To działa naprawdę, naprawdę dobrze. Użyjmy tego samego rozwiązania w naszym kodzie. W tej chwili mamy twardo zakodowany modyfikator "padding" o okropnej wartości 20. Nie chcemy tego już. Usuńmy ten modyfikator i zamiast tego powiedzmy, że nasz widok przewijalny ma nowy modyfikator "content margins". Znowu używamy wartości 20, tej samej wartości, określając zawartość widoku przewijalnego. Przyciśnij obszar bezpieczny o podaną liczbę. Krytyczne jest również, aby przenieść modyfikatory `.listRowInsets(EdgeInsets())` na koniec listy modyfikatorów dla tego widoku. Zawsze mów, że nie ma kolejnych wcięć po tych, o których ci powiedziałem. 

```swift
ScrollView(.horizontal, showsIndicators: false) {
  HStack {
    ForEach(items) { item in
                    ItemView(item: item)
                   }
  }
  .scrollTargetLayout()
}
.scrollTargetBehavior(.viewAligned)
.contentMargins(20, for: .scrollContent)
.listRowInsets(EdgeInsets())
```



To niewielka zmiana. Dodanie kolejnego modyfikatora, usunięcie jednego z modyfikatorów, ale działa to tak dobrze. Wracając jeszcze raz do naszego kodu, teraz mogę przesuwać się między różnymi potrawami. Jak widzisz, teraz wypełniają ekran od krawędzi do krawędzi. Dużo bardziej estetycznie. Ale nadal nie jest idealnie. Jak widzisz, jeśli wywołam ten widok, zwróć uwagę na krawędzie początkową i końcową. Nie są równe. Są obie widoczne, co jest świetne. Od krawędzi do krawędzi, co jest wspaniałe. Ale nie są równe. 

![image-20230918220540149](image-20230918220540149.png)

Możemy zrobić to lepiej. Znowu mamy nowy modyfikator iOS 17, który nazywa się "containerRelativeFrame". Pozwala nam powiedzieć, że ten widok potomny powinien mieć rozmiar oparty na rozmiarze jego rodzica. W tym przypadku mówimy, że rozmiar poziomy tego widoku ma być oparty na rozmiarze poziomym jego kontenera. Podajemy także rozmiar i osie, mówiąc, że oto rozmiar rodzica, jak duży powinien być ten widok potomny? Możemy na przykład powiedzieć, że dziecko powinno mieć rozmiar 0,5 rozmiaru rodzica, czyli na przykład połowę szerokości widoku rodzica. Albo może 0,333, czyli jedną trzecią szerokości widoku rodzica.



Istnieje bardziej zaawansowana alternatywa, która obejmuje osie (axis), liczbę (count), zakres (span) i odstęp (spacing). To oznacza, że chcemy podzielić nasz widok nadrzędny na 5 równych kolumn szerokości i każdy widok potomny wewnątrz ma stanowić dwie z tych pięciu kolumn. Zakres dwóch spośród pięciu. Lub możemy powiedzieć, że chcemy obejmować cztery spośród pięciu. To zależy od Ciebie. To jest bardzo elastyczne. Ale co najlepsze, najprostsza wersja "containerRelativeFrame" jest banalna. Po prostu podaj osie (axis). W tej wersji oznacza to, że chcemy dopasować pełną szerokość naszego kontenera po odjęciu obszaru bezpieczeństwa. I to jest idealne w tym przypadku. Ponieważ właśnie użyliśmy "content margins", aby dostosować obszar bezpieczeństwa w poziomych widokach przewijalnych. 

Teraz w naszym kodzie mamy widok "item view", który pokazuje jeden element w naszym układzie. Mogę kliknąć prawym przyciskiem na ten widok i wybrać "Przejdź do definicji". Następnie przewinąć się w dół tego układu jednego widoku w jedzeniu, napojach lub czymkolwiek, i odnaleźć to: "fixed frame width" zawsze wynoszący 320. To może działać wcześniej, ale teraz chcemy coś lepszego. Chcemy elastycznego rozmiaru zgodnie z widokiem nadrzędnym, do którego jest przypisany. Więc usunę to i zastosuję nowy modyfikator iOS 17, którym jest "containerRelativeFrame". Powiem, że dopasuj szerokość kontenera poziomo. To zmiana jednej linii. Bardzo prosta, ale efekt jest znakomity. Otrzymujemy taki układ, że przewijając się między widokami, mamy równą ilość informacji przed i po bokach. Równe rozmiary treści wewnątrz. To jest praktycznie klasyczny układ widoku w sklepie App Store, który pokazuje wskazówki dotyczące przewijania, pokazując, co pojawia się przed i po tym, co jest aktualnie widoczne, co ułatwia wizualne przewijanie. Jest to bardzo przyjemne i łatwe do wykonania. A teraz mamy naprawdę inteligentne przewijanie w naszej aplikacji. Użyliśmy modyfikatora "scroll target behavior", mówiąc, że przewiń do widoków, które Ci podaję. I mówimy, które widoki mają być przewijane, mówiąc, że są to widoki z "scroll target layout". Przesuń do wszystkich tych widoków w "HStack". Następnie zastosowaliśmy "content margins", aby dostosować obszar bezpieczeństwa dla widoku przewijalnego. I wreszcie powiedzieliśmy, że chcemy również zastosować "container relative frame" poziomo, aby widoki potomne dopasowały się do pełnej szerokości widoku przewijalnego pomniejszonej o ten obszar bezpieczeństwa. Teraz wszystkie te funkcje wymagają iOS 17. Istnieje więc duża szansa, że pomyślisz: "Poczekaj chwilę. Nie mogę z nich korzystać przez jakiś czas. Muszę obsługiwać wersję 16 lub 15". Wróćmy więc i przyjrzyjmy się nieco starszemu kodowi, który nadal jest bardzo wartościowy dla Twojego projektu.

>  For example, here in this item view file here, on line 51, you can see we have a rounded rectangle with a corner radius of 25. Now how many times have you written code like that? Almost certainly lots and lots. New. From Xcode 15 and onwards, we can now just say ClipShape.RectCornerRadius 25 and get exactly the same result. A rounded rect of 25 point rounding. And brilliantly, this works back to iOS 13. And this happens because in Xcode 15's SwiftUI interface file is this code right here. It's saying to us there's a new method available in iOS 13 onwards. It's called rect with corner radius and style. But internally it calls down to the older initializer for rounded rectangles, with a corner radius and style. But critically, it's marked "always emit" in the client. Copy this code into your build at compile time, which is why it works back to iOS 13, as long as you have Xcode 15 or later. By the way, just briefly I want to say, if I go back to the .req again and say "what other options are there, you'll see .rect has a new option here, .rect corner radii. And this thing produces an uneven rounded rectangle, where you can say, like, round these two corners, but keep these two straight. It's full control for the rounding of corners. And that works back to iOS 16. Anyway, we don't want that here, and so I'm going to undo that change, and we'll leave it back as we had it. And instead, let's try something else instead. We're going to say, "What else can we do?" Over in our search area, add another brilliant convenience code we can look at. The buttons this time. Buttons, you'll see we have two so far in our project. Very, very simple project. We have one here in our button item view that you can press to like a thing. So add one activity for Shinkansen or Yoshinoya or whatever. And there's a second button over here in our main listing view that handles erasing all our data. Now you'll know classic iOS 13 Swift UI code, we could say here's a button title with an action to run when it's tapped. 



Istnieje bardziej zaawansowana alternatywa, która obejmuje osie (axis), liczbę (count), zakres (span) i odstęp (spacing). To oznacza, że chcemy podzielić nasz widok nadrzędny na 5 równych kolumn szerokości i każdy widok potomny wewnątrz ma stanowić dwie z tych pięciu kolumn. Zakres dwóch spośród pięciu. Lub możemy powiedzieć, że chcemy obejmować cztery spośród pięciu. To zależy od Ciebie. To jest bardzo elastyczne. Ale co najlepsze, najprostsza wersja "containerRelativeFrame" jest banalna. Po prostu podaj osie (axis). W tej wersji oznacza to, że chcemy dopasować pełną szerokość naszego kontenera po odjęciu obszaru bezpieczeństwa. I to jest idealne w tym przypadku. Ponieważ właśnie użyliśmy "content margins", aby dostosować obszar bezpieczeństwa w poziomych widokach przewijalnych. 

Teraz w naszym kodzie mamy widok "item view", który pokazuje jeden element w naszym układzie. Mogę kliknąć prawym przyciskiem na ten widok i wybrać "Przejdź do definicji". Następnie przewinąć się w dół tego układu jednego widoku w jedzeniu, napojach lub czymkolwiek, i odnaleźć to: "fixed frame width" zawsze wynoszący 320. To może działać wcześniej, ale teraz chcemy coś lepszego. Chcemy elastycznego rozmiaru zgodnie z widokiem nadrzędnym, do którego jest przypisany. Więc usunę to i zastosuję nowy modyfikator iOS 17, którym jest "containerRelativeFrame". Powiem, że dopasuj szerokość kontenera poziomo. To zmiana jednej linii. Bardzo prosta, ale efekt jest znakomity. Otrzymujemy taki układ, że przewijając się między widokami, mamy równą ilość informacji przed i po bokach. Równe rozmiary treści wewnątrz. To jest praktycznie klasyczny układ widoku w sklepie App Store, który pokazuje wskazówki dotyczące przewijania, pokazując, co pojawia się przed i po tym, co jest aktualnie widoczne, co ułatwia wizualne przewijanie. Jest to bardzo przyjemne i łatwe do wykonania. A teraz mamy naprawdę inteligentne przewijanie w naszej aplikacji. Użyliśmy modyfikatora "scroll target behavior", mówiąc, że przewiń do widoków, które Ci podaję. I mówimy, które widoki mają być przewijane, mówiąc, że są to widoki z "scroll target layout". Przesuń do wszystkich tych widoków w "HStack". Następnie zastosowaliśmy "content margins", aby dostosować obszar bezpieczeństwa dla widoku przewijalnego. I wreszcie powiedzieliśmy, że chcemy również zastosować "container relative frame" poziomo, aby widoki potomne dopasowały się do pełnej szerokości widoku przewijalnego pomniejszonej o ten obszar bezpieczeństwa. Teraz wszystkie te funkcje wymagają iOS 17. Istnieje więc duża szansa, że pomyślisz: "Poczekaj chwilę. Nie mogę z nich korzystać przez jakiś czas. Muszę obsługiwać wersję 16 lub 15". Wróćmy więc i przyjrzyjmy się nieco starszemu kodowi, który nadal jest bardzo wartościowy dla Twojego projektu.



> Then in iOS 14, they added a label view, so we could say as a trade enclosure, show some text and image in our button and adapt correctly based on the system you're running on right now. But there's a new option here without a trade enclosure. We can now specify a title and image and action straight in the button initializer and this works back to iOS 14. Again you have to have Xcode 15 or later to use this but it backports beautifully back to iOS 14. So we can simplify our two pieces of button code with this new initializer. Back in our project. Here's our erasing code right now. You can see how this label erased data and system image. I'm going to select that piece of code here and command X that to my clipboard and paste it into the button initializer and simply delete the trailing closure. It's no longer needed. Similarly for the other button code here. The same thing again. We have this call data model count for item with system image attached to it. And so again, I'll select that text, command X to my clipboard, get it out of there, and then remove the training closure and paste it into the button initialiser directly. Much simpler code. So, convenience ways to make rounded rects, circles, capsules and much more, plus nicer ways to make buttons. And of course, neither of those actually change the way our app actually looks. It looks the same way no matter what. So let's look at some changes that affect the way our apps actually look at runtime. Starting with a search. In the app, if I search for "miss" we'll find "miss the donut". But it says "one foods". And clearly, that's not ideal. We can do better than that. You'll know that English is very irregular about how it handles plural forms. We could say there is one drink and two drinks. Simple. Add an S. Easy peasy. But then it's one person but two people. Or we could say I want to have one mouse and two mice. And my personal favourite, I want to have one sheep and two sheep. And I guess a particular way when you factor in that we have zero using plural as well. Zero drinks, zero people. Plural, despite there being none other thing attached to it. This is clearly absolutely infuriating for folks trying to translate all this text. And so you get people writing code that's quite lazy. For example, if you have two integers, one and five, you'd say num1 drinks with the s being in parentheses. And that way, 1 or 5 both look the same. 



Następnie w iOS 14 dodali widok etykiety (label view), dzięki któremu mogliśmy w przycisku podać tekst i obrazek oraz dostosować go odpowiednio na podstawie systemu, na którym działa aplikacja. Ale jest tu nowa opcja bez etykiety. Teraz możemy określić tytuł, obraz i akcję bezpośrednio w inicjalizatorze przycisku, co działa wstecz do iOS 14. Znowu musisz mieć Xcode 15 lub nowszy, aby to używać, ale działa wspaniale wstecz do iOS 14. Możemy więc uprościć nasz kod przycisku za pomocą tego nowego inicjalizatora. Wracając do naszego projektu. Oto nasz obecny kod do usuwania danych. Widzisz, jak to działa - etykieta "Erase Data" i obrazek systemowy. Wybieram ten fragment kodu, kopiuję go (Command + X) do schowka, a następnie wklejam go bezpośrednio do inicjalizatora przycisku i po prostu usuwam nawias końcowy - nie jest już potrzebny. Podobnie dla drugiego kawałka kodu przycisku. To samo jeszcze raz. Mamy ten fragment kodu "dataModel.countForItem" z obrazkiem systemowym dołączonym do niego. Znowu wybieram ten tekst, kopiuję go (Command + X) do schowka, usuwam nawias końcowy i wklejam go bezpośrednio do inicjalizatora przycisku. O wiele prostszy kod. 

Więc oto wygodne sposoby na tworzenie zaokrąglonych prostokątów, okręgów, kapsułek i wiele więcej, a także przyjemniejsze sposoby tworzenia przycisków. Oczywiście żadna z tych zmian nie wpływa na to, jak nasza aplikacja wygląda w rzeczywistości. Wygląda ona tak samo, niezależnie od tego, jakie zmiany wprowadzimy. Teraz przejdźmy do zmian, które wpływają na wygląd naszych aplikacji podczas działania. Rozpocznijmy od wyszukiwania. W aplikacji, jeśli wyszukam "miss", znajdę "miss the donut". Ale jest napisane "one foods". I oczywiście, to nie jest idealne. Możemy zrobić to lepiej. Wiesz, że język angielski jest bardzo nieregularny w zakresie form liczby mnogiej. Możemy powiedzieć, że jest jeden napój i dwa napoje. Proste. Dodaj "s". Łatwe. Ale potem mamy jedną osobę, a dwie osoby. Albo możemy powiedzieć, że chcemy mieć jedną mysz i dwie myszy. I mój osobisty faworyt, chcę mieć jedno owce i dwie owce. I chyba jest szczególnie trudno wtedy, gdy uwzględnimy fakt, że mamy również liczbę zero w liczbie mnogiej. Zero napojów, zero osób. Forma mnoga, pomimo że nie ma nic do niej dołączonego. To jest oczywiście frustrujące dla osób, które próbują tłumaczyć cały ten tekst. Dlatego niektórzy programiści piszą leniwy kod. Na przykład, jeśli masz dwie liczby całkowite, jedną i pięć, możesz napisać "num1 drinks", a literka "s" będzie w nawiasach. W ten sposób 1 lub 5 wyglądają tak samo.



> One drinks or 5 drinks, they look the same no matter what. And people pluralise in their head. Now, helpfully, this kind of code isn't required anymore. Instead, we can ask SwiftUI to pluralise it automatically. Take the integer, say "drink" and select "true" for any number. And we'll use "drink" both times as singular. We don't care anymore. Because SwiftUI will automatically make it plural. It will say one drink or five drinks or zero drinks or 500 drinks automatically. This is really easy to adopt in your project. In our case, we can go over to our Xcode project, we can load up the JSON file that powers all our data. You'll see here on line 3 it says foods. I don't care about plural or singular anymore. I'm going to say food. Across the board, singular. Similarly, I can scroll down and find where it says 'drinks' down here and say 'just use drink always, stay singular'. At the bottom, 'activities' becomes 'activity'. Everywhere, singular. So our data is now simpler. And now we can go over to our listing view file and find where those strings are used. And it's up here in the section header. You can see that a text view being shown, and it calls inside there, "DataModel.TitleForSomeCategory". What we're going to do is, we're going to right-click on that TitleFor method, and jump to the definition. Show me that code! And there it is. We're saying, "ItemsCount.CategoryId". So, zero foods, one foods, three activities, zero activities, whatever it is. The pluralization isn't happening here. But notice how I've marked this method as returning a localised string key. SwiftUI knows how to localise these things for us. And so we can upgrade to the new automatic pluralisation. I'll change this code to say I'll take this whole string and make it inflected automatically. Again a tiny one line change. Not even a one line change. A half line change right now. But the result is quite brilliant. When our project runs again, you'll see, I'll do another search. Up here, we can look for again, our shin. And you'll see we have one food, zero drinks, one activity. It's correctly pluralising everything inside there for us. 

Jedno napoje lub 5 napojów, wyglądają tak samo, bez względu na liczbę. Ludzie tworzą formy liczby mnogiej w swojej głowie. Teraz na szczęście taki kod nie jest już wymagany. Zamiast tego możemy poprosić SwiftUI o automatyczną zmianę formy liczby mnogiej. Weź liczbę całkowitą, powiedz "napój" i wybierz "true" dla dowolnej liczby. I będziemy używać "napój" zawsze w formie pojedynczej. Nie obchodzi nas to już. Ponieważ SwiftUI automatycznie przekształci to w formę mnogą. Automatycznie powie "jeden napój" lub "pięć napojów" lub "zero napojów" lub "500 napojów". To naprawdę łatwe do wdrożenia w Twoim projekcie. W naszym przypadku możemy przejść do naszego projektu Xcode, możemy załadować plik JSON, który zasila wszystkie nasze dane. Zobaczysz tutaj, w linii 3 jest napisane "foods". Nie obchodzi mnie już, czy to jest liczba mnoga czy pojedyncza. Powiem po prostu "food". Wszędzie, w formie pojedynczej. Podobnie mogę przewinąć w dół i znaleźć "drinks" tutaj i powiedzieć "używaj zawsze 'drink', pozostaw w formie pojedynczej". Na dole "activities" staje się "activity". Wszędzie, w formie pojedynczej. Nasze dane są teraz prostsze. A teraz możemy przejść do naszego pliku widoku listy i znaleźć, gdzie są używane te ciągi znaków. I jest to tutaj, w nagłówku sekcji. Możesz zobaczyć, że jest tam widok tekstowy i wywołuje wewnątrz "DataModel.TitleForSomeCategory". Co zamierzamy zrobić, to kliknąć prawym przyciskiem na tej metodzie TitleFor i przejść do definicji. Pokaż mi ten kod! I oto jest. Mówimy "ItemsCount.CategoryId". Więc zero jedzenia, jedno jedzenie, trzy aktywności, zero aktywności, cokolwiek to jest. Formy mnogie nie są używane tutaj. Ale zauważ, że oznaczyłem tę metodę jako zwracającą klucz łańcucha lokalizacyjnego. SwiftUI wie, jak lokalizować te rzeczy dla nas. I możemy zaktualizować to do nowej automatycznej formy mnogiej. Zmienię ten kod, aby powiedzieć, że cały ten ciąg zostanie automatycznie zmieniony w formę mnogą. Znowu niewielka zmiana jednolinijkowa. Nawet nie jednolinijkowa. Teraz to półlinijkowa zmiana. Ale efekt jest znakomity. Kiedy nasz projekt zostanie uruchomiony ponownie, zobaczysz, że wykonam kolejne wyszukiwanie. Tutaj możemy znów szukać "shin". I zobaczysz, że mamy jedzenie, zero napojów, jedna aktywność. Wszystko jest poprawnie przekształcane w formę mnogą dla nas.



> This is done by an underlying foundation system called Automatic Grammar Agreement. It was introduced a few iOS versions ago, iOS 15, for English and Spanish. But they've added to it since then. They've said in iOS 16 we'll add French, Italian and Brazilian Portuguese. And in iOS 17 they've added European Portuguese and German. So we get a whole bunch of common European languages available automatically inflected in our code, with no extra work from us. It's really, really nice. Now of course, my app is about Japan. So you might think, "Well, how does it work with Japanese?" The answer is, Japanese is a much, much simpler language with no complex plurals. It's just out of the box works as a language. Anyway, let's look at some view layout changes too. If I scroll through my various types of food, you'll see they're not all exactly the same size. Here, for example, is milk roll. It's a one line description and if I scroll back and hold it slightly, you'll see it's slightly shorter than the smoothies next to it. It doesn't look great. Now, this kind of discrepancy happens because I've just said, "Show the item description in some text." Classic iOS 13 SwiftUI code. You also know we could say the same thing has a line limit of 2. Grow up to 2 lines but no further. Again, classic iOS 13 code. But from iOS 16 and later, we can now say there's a line limit range. No less than 2, no more than 5. Or we can also say I want exactly 2, reserving space for 2. So if it's 1 line or 0 lines, still leave 2 lines of space. So all our things pick up exactly the same height. It's a much nicer and more consistent way of showing text. In our project, we're here already in item view, showing one thing in one category. And then if I scroll up to find where this text is, boom, there it is in line 30. I can say the line limit here of exactly two lines reserving space. So if it is one line, make it two. If it's zero lines, make it two. If it's five lines, make it two. Stick to a consistent size. Small change, again just one line of SwiftUI code here. And yet, back in our project, you'll see the result is quite brilliant. As we swipe through, all our views have exactly the same height. Even when you swipe backwards a little bit, it still looks exactly the same height, no matter how long the description is. Next up, my all-time favourite SwiftUI feature, which is automatic colour gradients. You'll see these things have a blue bar at the bottom. Behind "Milk Roll" and "White" is this blue box. It gives some contrast there. This is done because inside our item view code here, we're saying behind all the text, I want you to apply here on line 45, a blue background color. If we say ".blue.gradient", we'll get the tiniest color gradient. Just a little bit of a lift there. Slightly lighter at the top, slightly darker below. It looks fantastic out of the box. Here's the result. Boom. There we go. Just a slight, slight blue gradient. It looks great with hardly any change whatsoever. I particularly like the fact this works across the whole range of SwiftUI built-in colours, plus all your own custom colours too. Speaking of colour, you'll know that SwiftUI has SF Symbols support built right in, right in and of course all these work in multicolour. What we've got to do is say a symbol rendering mode of multicolour and we get lovely multicolour rainbows or sunshine or battery symbols and more. But new in iOS 17 is another fantastic SF Symbols modifier called Symbol Effect to add an animation to these symbols. The question is what goes here? It depends the result you want. For example, you might say I want to have a variable colour animation to make the various waves of my rainbow fade through one at a time, in this case cumulatively. Or you might say I want to have a reversing variable colour so it fades all the way up then all the way down again and again and again. Or you might say I want to have a variable colour iterative so only one band of the rainbow expands out with color at any given time. Or perhaps it's variable color and then iterative and reversing. So it goes all the way up, then all the way down, one band at a time. It looks fantastic. 





To przeprowadzane jest za pomocą podstawowego systemu fundamentów nazywanego Automatycznym Porozumieniem Gramatycznym. Zostało to wprowadzone kilka wersji iOS temu, w iOS 15, dla języka angielskiego i hiszpańskiego. Ale od tego czasu dodali do niego. W iOS 16 dodano języki francuski, włoski i brazylijski portugalski. A w iOS 17 dodano europejski portugalski i niemiecki. Dzięki temu mamy dostęp do wielu wspólnych języków europejskich, które są automatycznie fleksyjne w naszym kodzie, bez dodatkowej pracy z naszej strony. To naprawdę bardzo przydatne. Oczywiście moja aplikacja dotyczy Japonii. Możesz pomyśleć: "Jak to działa w przypadku języka japońskiego?" Odpowiedź brzmi, że japoński jest znacznie prostszym językiem, bez skomplikowanych form liczby mnogiej. Po prostu działa out of the box jako język. Teraz przejdźmy do niektórych zmian w układzie widoku. Jeśli przewijasz różne rodzaje jedzenia, zauważysz, że nie wszystkie są dokładnie takie same. Tutaj, na przykład, jest "milk roll". To krótki opis i jeśli przewijasz wstecz i przytrzymasz go trochę, zobaczysz, że jest nieco krótszy niż smoothie obok niego. To nie wygląda zbyt dobrze. Ten rodzaj niezgodności występuje dlatego, że mówimy po prostu: "Pokaż opis produktu jako tekst". To klasyczny kod SwiftUI z iOS 13. Wiesz też, że możemy to zrobić jako limit wierszy 2. Rozwijaj się do 2 wierszy, ale nie dłużej. To również klasyczny kod z iOS 13. Ale od iOS 16 i dalej możemy teraz określić zakres limitu wierszy. Nie mniej niż 2, nie więcej niż 5. Lub możemy także powiedzieć, że chcemy dokładnie 2, zachowując miejsce na 2. Dlatego jeśli to jest 1 wiersz lub 0 wierszy, nadal zostawmy 2 wiersze miejsca. Wszystkie nasze rzeczy będą miały dokładnie ten sam rozmiar. To znacznie lepszy i bardziej spójny sposób wyświetlania tekstu. W naszym projekcie jesteśmy już w widoku elementu, pokazując jedną rzecz w jednej kategorii. Następnie przewiń w górę, aby znaleźć ten tekst, oto go na linii 30. Mogę powiedzieć, że limit wierszy wynosi dokładnie dwa wiersze, zachowując miejsce. Dlatego jeśli to jest jeden wiersz, zróbmy dwa. Jeśli to zero wierszy, zróbmy dwa. Jeśli to pięć wierszy, zróbmy dwa. Trzymajmy się jednolitego rozmiaru. Mała zmiana, znowu tylko jedna linia kodu SwiftUI tutaj. A jednak w naszym projekcie wynik jest naprawdę świetny. Kiedy przesuwamy, wszystkie nasze widoki mają dokładnie ten sam rozmiar. Nawet gdy przesuwamy trochę wstecz, nadal wyglądają dokładnie tak samo, bez względu na to, jak długi jest opis. Następnie mój ulubiony na całym świecie funkcja SwiftUI, czyli automatyczne gradienty kolorów. Zobaczysz, że te rzeczy mają niebieską belkę na dole. Za "Milk Roll" i "White" jest niebieska skrzynka. Dodaje to trochę kontrastu. To jest robione, ponieważ w kodzie widoku elementu mówimy: "za wszystkim tekstem chcę, żebyś zastosował tutaj na linii 45, niebieski kolor tła". Jeśli powiemy ".blue.gradient", dostaniemy najmniejszy gradient kolorów. Trochę jaśniejszy u góry, trochę ciemniejszy na dole. To wygląda fantastycznie od razu. Oto wynik. Boom. Oto mamy. Tylko trochę niebieskiego gradientu. To

 wygląda świetnie bez większych zmian. Szczególnie podoba mi się fakt, że działa to w całym zakresie wbudowanych kolorów SwiftUI, a także we własnych niestandardowych kolorach. Mówiąc o kolorze, wiesz, że SwiftUI ma wbudowane wsparcie dla symboli SF Symbols, a wszystkie one działają w wielokolorze. Musimy tylko powiedzieć, że chcemy trybu renderowania symbolu w wielokolorze, i dostajemy piękne tęcze w wielu kolorach, słońca, symbole baterii i wiele innych. Ale nowością w iOS 17 jest inny fantastyczny modyfikator symboli SF Symbols o nazwie Symbol Effect, który dodaje animację do tych symboli. Pytanie brzmi, co tutaj wpisujemy? To zależy od rezultatu, który chcesz uzyskać. Na przykład możesz powiedzieć, że chcesz mieć animację zmiennokolorową, aby różne fale twojej tęczy migały pojedynczo, w tym przypadku kumulacyjnie. Lub możesz powiedzieć, że chcesz mieć odwracalny zmiennokolor, więc miga całą drogę w górę, a potem całą drogę w dół, i tak w kółko. Lub możesz powiedzieć, że chcesz mieć zmiennokolorową iterację, więc tylko jedna strona tęczy rozszerza się z kolorem w danym momencie. Albo może być to zmiennokolorowe i iteracyjne i odwracalne. Więc idzie całą drogę w górę, potem całą drogę w dół, po jednej stronie tęczy na raz. To wygląda fantastycznie.

> You can even say let's not dim the unused parts of the rainbow, let's hide them entirely. And now what you'll see is we get individual things being visible one at a time with the dimmed parts of the rainbow being invisible completely. And if you really want to, you can do variable colour, iterative, high and active layers and reversing. The full effect. I want the whole thing, one at a time, fading in, fading out, all the way up, all the way down, again, again, again. It's exactly, so much control here, depending on what you want to try and do. Anyway, in our app, we've got a simple dummy loading screen with a little antenna bar being visible. We can find this in the project code over in the loading view. This thing has a symbol right here, antenna, radio waves left and right, and a nice big font. That's an animatable symbol. We can say I want to use here that extra new modifier of symbol effect. I'll say .symbol effect, then say I want to use the variable color effect with the iterative mode. Show one piece of the radio waves animating at a time, kind of fading, pulsing up and down again and again and again. A tiny change. If I artificially delay the loading screen so it lasts longer, you'll see the result is this. The radio waves kind of pulsing out again and again and again, infinitely. A tiny, tiny change. Again, just one line of code, but a lovely result. Next up, right now if I find something I like, I can say, "Yeah, I did this thing some number of times." For example, I might say, "Oh yes, my favourite drink right now is Calpis water." I can press that thing, "Yeah, I liked it." And do it again and again and again and again and again and again and again and again. Tap the button repeatedly. And that works. It works okay. Now, you'll know that classic iOS 13 button code, some button title, some action to run behind the scenes. We can also now in iOS 17 apply a button repeat behaviour saying "Enable it here". What will happen is, if you press the button, it triggers the action. If you keep pressing it, it triggers it again and again and again and again at increasing speeds automatically. Again, there's one line change here. So in our code, I go from loading view over to our item view and then scroll up to find the button. There it is. That's our button code right there. 

Możesz nawet powiedzieć: "Nie zamierzamy przyciemniać nieużywanych części tęczy, ukryjmy je całkowicie". Teraz zobaczysz, że pojedyncze elementy stają się widoczne po jednym, a przyciemnione części tęczy są całkowicie niewidoczne. A jeśli naprawdę chcesz, możesz zastosować zmienne kolory, iteracyjne, wysokie i aktywne warstwy oraz odwracanie. Pełny efekt. Chcę, żeby cała rzecz działała, pojedynczo, zanikała, pojawiała się, schodziła w dół, znowu, znowu, znowu. To naprawdę daje tak wiele kontroli, zależnie od tego, co chcesz spróbować zrobić. W każdym razie w naszej aplikacji mamy prosty ekran ładowania z małą belką anteny widoczną. Możemy znaleźć to w kodzie projektu w widoku ładowania. To ma symbol tutaj, antenę, fale radiowe w lewo i w prawo, oraz ładną dużą czcionkę. To jest animowany symbol. Możemy powiedzieć, że chcemy użyć tego dodatkowego nowego modyfikatora symbolu, czyli symbol effect. Powiem .symbol effect, a następnie powiem, że chcę użyć efektu zmiennej kolorystyki z trybem iteracyjnym. Pokażmy jedną część fal radiowych animującą się jednocześnie, trochę zanikającą, pulsującą w górę i w dół, znowu i znowu i znowu. Mała zmiana. Jeśli sztucznie opóźnimy ekran ładowania, aby trwał dłużej, zobaczysz, że efektem jest to. Fale radiowe pulsują w górę i w dół, znowu i znowu, w nieskończoność. Mała, mała zmiana. Znowu, tylko jedna linia kodu, ale wynik jest piękny. Następnie, obecnie, jeśli znajdę coś, co mi się podoba, mogę powiedzieć: "Tak, zrobiłem to kilka razy". Na przykład mogę powiedzieć: "Oh tak, moim ulubionym napojem teraz jest woda Calpis". Mogę nacisnąć ten przycisk, "Tak, mi się podobało". I robię to znowu i znowu i znowu i znowu i znowu i znowu i znowu i znowu. Kliknij przycisk wielokrotnie. I działa. Działa dobrze. Teraz wiesz, że klasyczny kod przycisku iOS 13 to jakiś tytuł przycisku i jakaś akcja do uruchomienia w tle. Teraz w iOS 17 możemy również zastosować zachowanie przycisku repeat, mówiąc "Włącz to tutaj". Co się stanie, to że jeśli naciśniesz przycisk, to uruchomi akcję. Jeśli będziesz go naciskać dalej, to będzie uruchamiał ją ponownie i ponownie i ponownie, automatycznie z coraz większą prędkością. Znowu, jest to jedna linia zmiany. W naszym kodzie przechodzimy z widoku ładowania do widoku elementu, a następnie przewijamy w górę, aby znaleźć przycisk. Oto jest. To jest nasz kod przycisku właśnie tutaj.



> We want that to have the button repeat behavior enabled. And so I'll say below the button, add.buttonRepeatBehaviorEnabled. And that's it. Another simple one line improvement to our project. So I run the code again and find something I like a lot, which is everything in Japan quite frankly, like Milk Roll. I can just press and hold and watch what happens. It adds one to it. It adds more and more and more, faster and faster and faster until it gets a maximum speed. It's pressing and holding, triggering again and again and again. All done automatically by SwiftUI in a platform sensible way. Mac OS, iOS, TUS and similar, automatic. Next up, what happens if we have no results to show when we're searching? Let's find out. I've got a search box and I'll search something that isn't there, like VZBooks, and there's nothing in there. A big white screen appears. The question is, what should be in there? And the answer is, I don't really know. And for a long time, Apple didn't really know either. If you asked the Mail app for an unknown search, it would say "No results found in grey text". If you asked the App Store, it would say "No results in a big, bold, white text". Your search term below. If you asked Photos, it would say "No results for your search text. Try a new search". If you asked the Weather app, "Get a little icon". No results. If you asked the Files app, it would say "Check the spelling or try a new search". And if you asked iTunes, you'd get a huge icon with no results for your search term. So simply, Apple had no standard way of saying "Sorry, I didn't get that. Try again." But, as of iOS 17, there's a new Content Unavailable view. We can say "No Results" with the custom SF symbol and get a fixed, standard layout saying there were no results found. the right font, the right weight, the right icon style and more. If you want to add an extra line of text, you can do. You can say, "Please search again," for example, and you'll get that shown below in a smaller, dimmer font. 



Chcemy, aby zachowanie przycisku repeat było włączone. I więc powiem poniżej przycisku, dodaj .buttonRepeatBehaviorEnabled. I to wszystko. Kolejna prostsza poprawka jednolinijkowa w naszym projekcie. Uruchamiam kod ponownie i znajduję coś, co mi się bardzo podoba, co tak naprawdę jest wszystkim w Japonii, jak na przykład Milk Roll. Mogę po prostu nacisnąć i przytrzymać i zobaczyć, co się stanie. Dodaje jedno do tego. Dodaje więcej i więcej i więcej, szybciej i szybciej, aż osiągnie maksymalną prędkość. Naciskam i przytrzymuję, wyzwalając to znów i znów i znów. Wszystko to automatycznie, dzięki SwiftUI, w sposób dostosowany do platformy. Mac OS, iOS, TUS i podobne, automatycznie. Następnie, co się dzieje, jeśli nie mamy wyników do pokazania podczas wyszukiwania? Przekonajmy się. Mam pole wyszukiwania i wyszukam coś, czego tam nie ma, na przykład VZBooks, i nic tam nie ma. Pojawi się duży biały ekran. Pytanie brzmi, co powinno się tam znaleźć? Odpowiedź brzmi: nie bardzo wiem. I przez długi czas Apple również nie bardzo wiedziało. Jeśli zapytałeś aplikację Mail o nieznane wyszukiwanie, powiedziałaby "Nie znaleziono wyników" szarym tekstem. Jeśli zapytałeś App Store, powiedziałby "Brak wyników" dużym, wyraźnym, białym tekstem. Twoje słowo kluczowe poniżej. Jeśli zapytałeś Photos, powiedziałby "Brak wyników dla twojego tekstu wyszukiwania. Spróbuj nowego wyszukiwania". Jeśli zapytałeś aplikację Pogoda, dostaniesz małą ikonkę. Brak wyników. Jeśli zapytałeś aplikację Pliki, powiedziałaby "Sprawdź pisownię lub spróbuj nowego wyszukiwania". A jeśli zapytałeś iTunes, dostałbyś ogromną ikonkę z niewłaściwymi wynikami dla twojego słowa kluczowego. Po prostu Apple nie miało standardowego sposobu na powiedzenie "Przepraszam, nie zrozumiałem. Spróbuj ponownie". Ale od iOS 17 jest nowy widok "Brak dostępnych treści". Możemy powiedzieć "Brak wyników" z niestandardowym symbolem SF i uzyskać ustaloną, standardową strukturę mówiącą, że nie znaleziono wyników. odpowiednią czcionką, odpowiednim stylem ikony i wiele innych. Jeśli chcesz dodać dodatkową linię tekstu, możesz to zrobić. Możesz powiedzieć na przykład "Proszę wyszukać ponownie", a zostanie to wyświetlone poniżej w mniejszej, przygaszonej czcionce.



> Again, all taken care of for us automatically. If you want full control, you can say, "Show a custom content available view with my exact image font size and text here, then some text below for description and then custom actions with a border prominent style. And it will take care of all that for you and make it look correct for the platform it's running on. And best of all, for the simplest case of all, which is the most common case of all, no search results. You just say .search. And SwiftUI will look through your view hierarchy to find the nearest search bar, grab a text out of there that you typed, and show it in the UI automatically. It's really, really nice. Now in this app, we have three sections. Foods, drinks, and activities. So I'm going to show one unavailable view in each one of those categories, perhaps showing all three, depending on what the user searched for. So in our code, we're in the item view right now. We're going to go across to the listing view, And then inside here, all the way up here, this is the part of the code where we load the items for the current category, based on their search term. What we're going to say is, if that items array happens to be empty after the search has taken place, then we want a custom content unavailable view inside here. There's a whole bunch of ways of making it. I'm going to use title and system image. 

Znowu wszystko jest za nas automatycznie zadbane. Jeśli chcesz pełnej kontroli, możesz powiedzieć: "Pokaż niestandardowy widok dostępności treści z moim dokładnym obrazem, rozmiarem czcionki i tekstem tutaj, a następnie tekstem poniżej opisu i niestandardowymi działaniami w stylu prominent z obramowaniem. I wszystko zostanie za ciebie zrobione, a wygląd będzie odpowiedni dla platformy, na której działa. A co najlepsze, w najprostszym przypadku, który jest najbardziej powszechny, czyli brak wyników wyszukiwania. Po prostu powiedz .search. I SwiftUI przeszuka hierarchię widoków, aby znaleźć najbliższy pasek wyszukiwania, wydobyć z niego wprowadzony tekst i automatycznie go wyświetlić w interfejsie użytkownika. To naprawdę, naprawdę przydatne. W tej aplikacji mamy trzy sekcje: jedzenie, napoje i aktywności. Pokażę niestandardowy widok niedostępności w każdej z tych kategorii, być może pokażę wszystkie trzy, w zależności od tego, czego użytkownik szuka. Więc w naszym kodzie jesteśmy teraz w widoku elementu. Przejdziemy do widoku listy. A następnie wewnątrz tego miejsca w kodzie, tutaj, to jest część kodu, w której wczytujemy elementy dla bieżącej kategorii, w oparciu o wprowadzone słowo kluczowe. Powiemy, że jeśli tablica tych elementów okaże się pusta po przeprowadzeniu wyszukiwania, chcemy użyć niestandardowego widoku niedostępności treści wewnątrz tego miejsca. Istnieje wiele sposobów na jego utworzenie. Użyję tytułu i systemowego obrazu.

> For the title, I'm going to say, "Sorry, no food or similar matches the search text of" whatever they typed into the data model behind the scenes. So, their search string. So, no food matches that thing. Then for the image, I already have an icon attached to my category. So, I can say the image is the category's icon automatically. Like so. And then, everything else, the old scroll view code, that becomes the else block of our condition. The whole scroll view, all its modifiers, just push it all into the else block. Either show the unavailable view, or the content as before. And now when we press run the code, we'll get a much nicer result when we do a bad search. For example, in Japan, either I go to say McDonald's, if I search for McDonald's, boom. No food matched McDonalds, no drink matched McDonalds, no activity matched McDonalds. But a standard UI across the board. Ok, let's wrap up. You've seen how you can do scroll snapping by saying there's a scroll target behaviour for the scroll view. It could be whole pages or individual views. We then marked which views to snap to by using scroll target layout. Snap to all the children in this HDAC for example. Then we saw how to indent scroll content by bringing in the safe area inset for the scroll view by some amount. And then how to use relative sizing so a child gets its size from the parent container it sits inside. In this case, that takes into account the safe area inset of the container. We saw the new back-deployed helper code. We can say .rect, saving literally seconds every day. And how we can do simpler button code with title, image and action right there in the initialiser without using a trail enclosure. We saw the new automatic grammar agreement, 15, 16 and 17 supported, getting better every release with English, Portuguese, French, Italian, German and Spanish EPFIGs now being supported. And we saw how to do reservation of text size, to say always leave at least, or exactly in this case, two lines even if there's only one line of text inside there to keep a consistent spacing everywhere we went. 





Dla tytułu powiedzieliśmy "Przepraszamy, ale nie znaleziono jedzenia ani podobnych produktów pasujących do wyszukanej frazy", a jako frazę wprowadzoną przez użytkownika użyliśmy tekstu z modelu danych. Dla obrazka użyliśmy ikony przypisanej do naszej kategorii. Następnie cały kod związanego ze scroll view został przeniesiony do bloku else naszej instrukcji warunkowej. Teraz, gdy uruchomimy kod, otrzymamy znacznie lepszy wynik podczas wyszukiwania, które nie przynosi wyników. Na przykład w Japonii, gdy wyszukamy McDonald's, otrzymamy taki rezultat: "Nie znaleziono jedzenia pasującego do frazy McDonald's, nie znaleziono napoju pasującego do frazy McDonald's, nie znaleziono aktywności pasującej do frazy McDonald's." Ale wszędzie standardowy interfejs użytkownika. 

Podsumowując, zobaczyliśmy, jak można osiągnąć scroll snapping, korzystając z zachowań dla scroll view. Możemy ustawić przyciąganie do całych stron lub pojedynczych widoków. Następnie pokazaliśmy, jak odsuwać zawartość scroll view, uwzględniając safe area inset, oraz jak używać rozmiarów relatywnych, aby dziecko dostawało swoją wielkość od rodzica, uwzględniając inset obszaru bezpiecznego. Zobaczyliśmy nowy kod pomocniczy dla wygodniejszego tworzenia zaokrąglonych i innych kształtów. Przyjrzelismy się również uproszczonej konstrukcji przycisków oraz automatycznej zgody gramatycznej, która jest dostępna od iOS 15 i jest rozwijana w kolejnych wersjach systemu. Na koniec dowiedzieliśmy się, jak kontrolować rozmiar tekstu i zachować jednolity wygląd widoków przy różnych ilościach tekstu.



> We saw how to do automatic colour gradients. Dot blue dot gradient works for any of the built in SwiftUI colours and all your own colours too. And we saw how to do the new sf symbol animations by using dot variable colour dot iterative. We added button repeat behaviour so you could press and hold on buttons to trigger again and again and again. Plus, we now show a system standard content unavailable view, so all our UI looks the same across every app on the Apple platforms. Now, this was a fast video with lots of code being shown, of which only some you'll want to use in your project. And that's okay. I've shown you what's possible now. You can go away and say, oh yeah, this bit, this bit, yes, these ones, not so much, fine. That's fine. Decide which parts work for you, and take those and put them on into your project. And that's fine. Take what works for you. It's an iterative improvement. If you only have one code change from this talk, it's still worthwhile. It's not all or nothing. And remember, lots of things you saw here work in iOS 17 only. But some do backport backwards 16, 15, 14, and even 13 sometimes, but you very often do have to have that latest version of Xcode. code 15 or later. That's the emit into client attribute saying yes copy this new code into older compatible versions too. Anyway that's it from me. I hope you enjoyed the talk, learned something new along the way and you're ready to improve your Swift code in all sorts of cool ways. If you liked it hit like, please subscribe I make lots of other videos like this one and if you could leave a comment below saying what your favorite feature shown in this video was. Take care folks. [BLANK_AUDIO]

Zobaczyliśmy, jak tworzyć automatyczne gradienty kolorów za pomocą `.blue.gradient`, które działa zarówno dla wbudowanych kolorów SwiftUI, jak i własnych kolorów. Pokazaliśmy także nowe animacje dla symboli SF za pomocą `.variableColour.iterative`. Dodaliśmy zachowanie przycisku do wielokrotnego naciśnięcia, dzięki któremu można naciskać i trzymać przycisk, aby wywoływać akcję wielokrotnie. Ponadto, teraz pokazujemy standardowy widok niedostępności treści systemowej, dzięki czemu nasza cała aplikacja wygląda tak samo na wszystkich platformach Apple.

To było szybkie wideo z dużą ilością kodu, z którego nie wszystko będzie przydatne w twoim projekcie. To w porządku. Pokazałem, co jest teraz możliwe. Możesz wybrać się i powiedzieć: "O tak, ten fragment, ten fragment, tak, te, niekoniecznie". To w porządku. Zdecyduj, które części działają dla ciebie, i przekaż je do swojego projektu. To jest proces stopniowej poprawy. Jeśli masz tylko jedną zmianę kodu z tej prezentacji, to i tak warto. To nie jest wszystko albo nic. I pamiętaj, że wiele z tych funkcji działa tylko w iOS 17. Jednak niektóre z nich wspierają wersje wsteczne, takie jak 16, 15, 14, a nawet czasami 13, ale często musisz mieć najnowszą wersję Xcode, przynajmniej Xcode 15 lub nowszą.

To już wszystko ode mnie. Mam nadzieję, że podobała ci się ta prezentacja, że nauczyłeś się czegoś nowego i jesteś gotów, aby poprawić swój kod Swift w różny, ciekawy sposób. Jeśli ci się podobało, kliknij "lubię to", zasubskrybuj mój kanał - publikuję wiele innych filmów podobnych do tego - i zostaw komentarz poniżej, mówiąc, jaka funkcja była twoją ulubioną w tym filmie. Trzymaj się!